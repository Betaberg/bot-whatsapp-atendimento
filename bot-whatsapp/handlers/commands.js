const database = require('../db/database');
const config = require('../config/config');
const { OllamaClient: ollamaClient } = require('../utils/ollama-fix');
const { sendAdminNotification, emailTemplates } = require('../config/email');

class CommandHandler {
  constructor() {
    this.awaitingData = new Map(); // Para armazenar usu√°rios que est√£o fornecendo dados
    this.userSessions = new Map(); // Para rastrear sess√µes de usu√°rios
  }

  async handleMessage(message, sendMessage, userPhone, isGrupoTecnico = false) {
    try {
      const text = message.body?.trim() || '';
      let user = await database.buscarUsuario(userPhone);
      
      // Criar usu√°rio se n√£o existir
      if (!user) {
        await database.criarOuAtualizarUsuario(userPhone);
        user = await database.buscarUsuario(userPhone);
      }

      // Verificar se o usu√°rio √© um root user e atualizar o papel se necess√°rio
      if (config.whatsapp.rootNumbers.includes(userPhone) && user.role !== 'root') {
        await database.alterarRoleUsuario(userPhone, 'root');
        user = await database.buscarUsuario(userPhone);
      }

      // Verificar se o usu√°rio tem acesso root tempor√°rio
      if (user.temporaryRootExpires && new Date() < new Date(user.temporaryRootExpires)) {
        user.role = 'root';
      } else if (user.temporaryRootExpires) {
        // Expirar o acesso root tempor√°rio
        await database.removerAcessoRootTemporario(userPhone);
        user.role = await database.buscarUsuario(userPhone).role;
      }

      // Se o usu√°rio est√° fornecendo dados para uma OS ou pe√ßas
      if (this.awaitingData.has(userPhone)) {
        return await this.handleDataInput(text, sendMessage, userPhone);
      }

      // Processar comandos
      if (text.startsWith('!')) {
        return await this.processCommand(text, sendMessage, userPhone, user, isGrupoTecnico);
      }

      // Verificar se a mensagem come√ßa com "chamado" para abrir automaticamente
      if (text.toLowerCase().startsWith('chamado')) {
        // Extrair o conte√∫do ap√≥s "chamado" para usar como descri√ß√£o do problema
        const problema = text.substring(7).trim() || 'Chamado aberto automaticamente';
        return await this.createOrderFromProblem(problema, sendMessage, userPhone, user);
      }

      // Se n√£o √© um comando e n√£o √© do grupo t√©cnico, processar com IA
      if (!isGrupoTecnico) {
        return await this.handleUserInteraction(text, sendMessage, userPhone, user);
      }

    } catch (error) {
      console.error('Erro ao processar mensagem:', error);
      await sendMessage('‚ùå Ocorreu um erro interno. Tente novamente em alguns instantes.');
    }
  }

  async processCommand(text, sendMessage, userPhone, user, isGrupoTecnico = false) {
    const parts = text.split(' ');
    const command = parts[0].toLowerCase();
    const args = parts.slice(1);

    // Verifica√ß√£o adicional para o comando !abrir
    if (command === '!abrir' || command === '!Abrir') {
      return await this.handleDados(sendMessage, userPhone, args);
    }

    const userRole = user?.role || 'user';

    switch (command) {
      // Comandos gerais
      case '!ajuda':
        return await this.handleAjuda(sendMessage, userRole);
      
      case '!status':
        return await this.handleStatus(args, sendMessage, userPhone);
      
      case '!cancelar':
        return await this.handleCancelar(args, sendMessage, userPhone);
      
      case '!abrir':
        return await this.handleDados(sendMessage, userPhone, args);

      // Comandos de t√©cnicos
      case '!menu':
        return await this.handleMenu(sendMessage, userRole);
      
      case '!atendendo':
        return await this.handleAtendendo(args, sendMessage, userPhone, userRole);
      
      case '!prioridade':
        return await this.handlePrioridade(args, sendMessage, userRole);
      
      case '!setor':
        return await this.handleSetor(text, sendMessage, userRole);
      
      case '!mensagem':
        return await this.handleMensagem(text, sendMessage, userRole);
      
      case '!list':
        return await this.handleList(sendMessage, userRole);
      
      case '!finalizado':
        return await this.handleFinalizado(args, sendMessage, userRole);
      
      case '!adm':
        return await this.handleChamarAdmin(sendMessage, userRole);

      // Comandos de pe√ßas
      case '!listpe√ßas':
        return await this.handleListPecas(args, sendMessage, userPhone, userRole);
      
      case '!pecas':
        return await this.handleVerPecas(sendMessage, userRole);
      
      case '!atender':
        return await this.handleAtenderPecas(args, sendMessage, userPhone, userRole);

      // Comandos administrativos
      case '!config':
        return await this.handleConfig(sendMessage, userRole);
      
      case '!listtc':
        return await this.handleListTecnicos(sendMessage, userRole);
      
      case '!listadm':
        return await this.handleListAdmins(sendMessage, userRole);
      
      case '!menss':
        return await this.handleAlterarSaudacao(text, sendMessage, userRole);
      
      case '!msfinal':
        return await this.handleAlterarMensagemFinal(text, sendMessage, userRole);
      
      case '!ping':
        return await this.handlePing(sendMessage, userRole);
      
      case '!tecnico':
        return await this.handlePromoverTecnico(text, sendMessage, userRole);
      
      case '!admin':
        return await this.handlePromoverAdmin(text, sendMessage, userRole);
      
      case '!almoxarifado':
        return await this.handlePromoverAlmoxarifado(text, sendMessage, userRole);
      
      case '!historico':
        return await this.handleHistorico(sendMessage, userRole);

      // Comandos do sistema
      case '!user':
        return await this.handleCriarUsuario(text, sendMessage, userPhone, userRole);
      
      case '!grafico':
        return await this.handleGrafico(sendMessage, userRole);
      
      case '!backup':
        return await this.handleBackup(sendMessage, userRole);
      
      case '!sistema':
        return await this.handleSistema(sendMessage, userRole);

      // Comandos de controle da IA
      case '!iaon':
        return await this.handleIAOn(sendMessage, userRole);
      
      case '!iaoff':
        return await this.handleIAOff(sendMessage, userRole);
      
      case '!iastatus':
        return await this.handleIAStatus(sendMessage, userRole);

      // Comando para promover usu√°rio a root
      case '!root':
        return await this.handleMencionarRoot(sendMessage, userRole);

      // Comando para definir grupo t√©cnico
      case '!tcgrupo':
        return await this.handleDefinirGrupoTecnico(sendMessage, userPhone, userRole, isGrupoTecnico);

      default:
        await sendMessage('‚ùì Comando n√£o reconhecido. Digite !ajuda para ver os comandos dispon√≠veis.');
    }
  }

  // Comandos Gerais
  async handleAjuda(sendMessage, userRole) {
    let helpText = config.messages.ajuda;
    
    if (userRole === 'user') {
      helpText = `
ü§ñ *COMANDOS DISPON√çVEIS*

*USU√ÅRIOS:*
‚Ä¢ !ajuda - Lista de comandos
‚Ä¢ !status [id] - Ver status da OS
‚Ä¢ !cancelar [id] - Cancelar OS
‚Ä¢ !abrir - Abrir um novo chamado

Para abrir um chamado, use !abrir, digite "chamado [descri√ß√£o]" ou apenas descreva seu problema!
      `;
    }
    
    await sendMessage(helpText);
  }

  async handleStatus(args, sendMessage, userPhone) {
    if (args.length === 0) {
      return await sendMessage('‚ùå Use: !status [id da OS]');
    }

    const osId = args[0];
    const os = await database.buscarOS(osId);

    if (!os) {
      return await sendMessage(`‚ùå OS #${osId} n√£o encontrada.`);
    }

    // Verificar se o usu√°rio pode ver esta OS
    if (os.usuario_telefone !== userPhone) {
      const user = await database.buscarUsuario(userPhone);
      if (!user || !['tecnico', 'admin', 'root'].includes(user.role)) {
        return await sendMessage('‚ùå Voc√™ s√≥ pode consultar suas pr√≥prias OS.');
      }
    }

    const statusEmoji = {
      'aberta': 'üî¥',
      'em_andamento': 'üü°',
      'finalizada': 'üü¢',
      'cancelada': '‚ö´'
    };

    const response = `
üìã *OS #${os.id}*
${statusEmoji[os.status]} Status: ${os.status.toUpperCase()}
üë§ Usu√°rio: ${os.usuario_nome}
üìç Local: ${os.local_atendimento || 'N√£o informado'}
üíª Equipamento: ${os.equipamento || 'N√£o informado'}
üîß T√©cnico: ${os.tecnico_responsavel || 'N√£o atribu√≠do'}
‚ö° Prioridade: ${os.prioridade ? 'ALTA' : 'Normal'}
üè¢ Setor: ${os.setor}
üìÖ Criada: ${new Date(os.created_at).toLocaleString('pt-BR')}
    `;

    await sendMessage(response);
  }

  async handleCancelar(args, sendMessage, userPhone) {
    if (args.length === 0) {
      return await sendMessage('‚ùå Use: !cancelar [id da OS]');
    }

    const osId = args[0];
    const os = await database.buscarOS(osId);

    if (!os) {
      return await sendMessage(`‚ùå OS #${osId} n√£o encontrada.`);
    }

    if (os.usuario_telefone !== userPhone) {
      return await sendMessage('‚ùå Voc√™ s√≥ pode cancelar suas pr√≥prias OS.');
    }

    if (os.status === 'finalizada') {
      return await sendMessage('‚ùå N√£o √© poss√≠vel cancelar uma OS j√° finalizada.');
    }

    await database.atualizarStatusOS(osId, 'cancelada');
    await database.adicionarMensagemHistorico(osId, userPhone, 'OS cancelada pelo usu√°rio', 'system');
    
    await sendMessage(`‚úÖ OS #${osId} cancelada com sucesso.`);
  }

  async handleDados(sendMessage, userPhone, args) {
    // Se houver argumentos, significa que √© para adicionar dados a uma OS existente
    if (args && args.length > 0) {
      const osId = args[0];
      // Verificar se a OS existe
      const os = await database.buscarOS(osId);
      if (!os) {
        return await sendMessage(`‚ùå OS #${osId} n√£o encontrada.`);
      }
      
      // Verificar se o usu√°rio tem permiss√£o para adicionar dados
      const user = await database.buscarUsuario(userPhone);
      if (os.usuario_telefone !== userPhone && !['tecnico', 'admin', 'root'].includes(user?.role)) {
        return await sendMessage('‚ùå Voc√™ n√£o tem permiss√£o para adicionar dados a esta OS.');
      }
      
      // Iniciar processo de coleta de dados adicionais
      this.awaitingData.set(userPhone, { 
        step: 'dados_adicionais',
        osId: osId,
        type: 'additional_data'
      });
      
      return await sendMessage(`
üìù *ADICIONAR DADOS √Ä OS #${osId}*

Por favor, forne√ßa as informa√ß√µes adicionais:
      `);
    }
    
    // Se n√£o houver argumentos, iniciar processo normal de cria√ß√£o de OS
    this.awaitingData.set(userPhone, { step: 'nome' });
    await sendMessage(`
üìù *COLETA DE DADOS PARA CHAMADO*

Por favor, forne√ßa as seguintes informa√ß√µes:

1Ô∏è‚É£ Seu nome completo:
    `);
  }

  // Comandos de T√©cnicos
  async handleAtendendo(args, sendMessage, userPhone, userRole) {
    if (!['tecnico', 'admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para t√©cnicos.');
    }

    if (args.length === 0) {
      return await sendMessage('‚ùå Use: !atendendo [id da OS]');
    }

    const osId = args[0];
    const os = await database.buscarOS(osId);

    if (!os) {
      return await sendMessage(`‚ùå OS #${osId} n√£o encontrada.`);
    }

    if (os.status !== 'aberta') {
      return await sendMessage(`‚ùå OS #${osId} n√£o est√° dispon√≠vel para atendimento.`);
    }

    const user = await database.buscarUsuario(userPhone);
    await database.atualizarStatusOS(osId, 'em_andamento', user.nome || userPhone);
    await database.adicionarMensagemHistorico(osId, userPhone, `T√©cnico assumiu o atendimento`, 'tecnico');

    await sendMessage(`‚úÖ Voc√™ assumiu a OS #${osId}. Status alterado para EM ANDAMENTO.`);
  }

  async handleList(sendMessage, userRole) {
    if (!['tecnico', 'admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para t√©cnicos.');
    }

    const osAbertas = await database.listarOSAbertas();

    if (osAbertas.length === 0) {
      return await sendMessage('‚úÖ N√£o h√° OS abertas no momento.');
    }

    let response = 'üìã *ORDENS DE SERVI√áO ABERTAS*\n\n';
    
    osAbertas.forEach(os => {
      const prioridade = os.prioridade ? '‚ö°' : '';
      const status = os.status === 'aberta' ? 'üî¥' : 'üü°';
      
      response += `${status}${prioridade} *OS #${os.id}*\n`;
      response += `üë§ ${os.usuario_nome}\n`;
      response += `üìç ${os.local_atendimento || 'N/I'}\n`;
      response += `üíª ${os.equipamento || 'N/I'}\n`;
      response += `üîß ${os.tecnico_responsavel || 'N√£o atribu√≠do'}\n`;
      response += `üìÖ ${new Date(os.created_at).toLocaleString('pt-BR')}\n\n`;
    });

    await sendMessage(response);
  }

  // Novo tratamento de intera√ß√£o com usu√°rio usando IA
  async handleUserInteraction(text, sendMessage, userPhone, user) {
    try {
      // Verificar se √© a primeira intera√ß√£o do usu√°rio
      const isFirstInteraction = !this.userSessions.has(userPhone);
      
      if (isFirstInteraction) {
        // Marcar que o usu√°rio j√° interagiu
        this.userSessions.set(userPhone, {
          firstContact: new Date(),
          messageCount: 1
        });

        // Gerar mensagem de boas-vindas personalizada
        const welcomeMessage = await ollamaClient.generateWelcomeMessage(user?.nome || 'usu√°rio');
        await sendMessage(welcomeMessage);
        return;
      }

      // Atualizar contador de mensagens
      const session = this.userSessions.get(userPhone);
      session.messageCount++;
      this.userSessions.set(userPhone, session);

      // Analisar a mensagem do usu√°rio com IA
      const messageType = await ollamaClient.analyzeUserMessage(text);

      switch (messageType) {
        case 'SAUDACAO':
          await sendMessage(`üëã Ol√°! Como posso ajud√°-lo hoje?

üîß Descreva seu problema t√©cnico para abrir um chamado
üìã Use !ajuda para ver todos os comandos dispon√≠veis`);
          break;

        case 'DUVIDA':
          await sendMessage(`‚ùì Entendi que voc√™ tem uma d√∫vida sobre o sistema.

üìã Use !ajuda para ver todos os comandos dispon√≠veis
üîß Para abrir um chamado, descreva seu problema t√©cnico
üí¨ Posso ajudar com quest√µes de TI, impressoras, computadores, rede, etc.`);
          break;

        case 'PROBLEMA':
          // Criar OS para problemas t√©cnicos
          await this.createOrderFromProblem(text, sendMessage, userPhone, user);
          break;

        default:
          await sendMessage(`üí¨ Entendi sua mensagem.

üîß Se voc√™ tem um problema t√©cnico, descreva-o detalhadamente
üìã Use !ajuda para ver todos os comandos dispon√≠veis
üí° Posso ajudar com: computadores, impressoras, rede, sistemas, etc.`);
          break;
      }

    } catch (error) {
      console.error('Erro na intera√ß√£o com usu√°rio:', error);
      await sendMessage('‚ùå Ocorreu um erro. Tente novamente ou use !ajuda para ver os comandos dispon√≠veis.');
    }
  }

  // Criar OS a partir de problema identificado pela IA
  async createOrderFromProblem(text, sendMessage, userPhone, user) {
    try {
      // Analisar o problema com IA
      const analiseIA = await ollamaClient.analyzeProblem(text);

      // Criar OS
      const osData = {
        usuario_nome: user?.nome || 'Usu√°rio',
        usuario_telefone: userPhone,
        problema: text,
        setor: 'TI'
      };

      const osId = await database.criarOS(osData);
      await database.adicionarMensagemHistorico(osId, userPhone, text, 'user');

      let response = `
‚úÖ *CHAMADO CRIADO COM SUCESSO*

üé´ OS #${osId}
üìù Problema: ${text}
üìÖ Criado em: ${new Date().toLocaleString('pt-BR')}

ü§ñ *An√°lise Autom√°tica:*
üìÇ Categoria: ${analiseIA.categoria}
‚ö° Prioridade: ${analiseIA.prioridade}
üîç An√°lise: ${analiseIA.analise}

üí° *Pr√≥ximos passos:*
‚Ä¢ Use !abrir para adicionar mais informa√ß√µes
‚Ä¢ Use !status ${osId} para consultar o andamento
‚Ä¢ Nossa equipe t√©cnica foi notificada
      `;

      await sendMessage(response);

      // Notificar grupo t√©cnico
      await this.notifyTechnicalGroup(`
üÜï *NOVA OS CRIADA*

üé´ OS #${osId}
üë§ Usu√°rio: ${user?.nome || 'Usu√°rio'}
üìû Telefone: ${userPhone}
üìù Problema: ${text}

ü§ñ *An√°lise IA:*
üìÇ ${analiseIA.categoria} | ‚ö° ${analiseIA.prioridade}
üîç ${analiseIA.analise}

üìÖ Criado em: ${new Date().toLocaleString('pt-BR')}
      `);

      // Enviar notifica√ß√£o por e-mail para administradores
      if (config.email.adminEmails.length > 0) {
        try {
          // Buscar OS completa do banco
          const osCompleta = await database.buscarOS(osId);
          
          // Enviar notifica√ß√£o por e-mail
          const emailData = emailTemplates.newOrder(osCompleta);
          await sendAdminNotification(emailData.subject, emailData.text, emailData.html);
        } catch (emailError) {
          console.error('Erro ao enviar notifica√ß√£o por e-mail:', emailError);
        }
      }

      return { osId, created: true };

    } catch (error) {
      console.error('Erro ao criar OS:', error);
      await sendMessage('‚ùå Erro ao criar chamado. Tente novamente ou entre em contato com o suporte.');
    }
  }

  // Tratamento de entrada de dados
  async handleDataInput(text, sendMessage, userPhone) {
    const userData = this.awaitingData.get(userPhone);
    
    // Verificar se √© para autentica√ß√£o de usu√°rio root
    if (userData.step === 'login') {
      userData.login = text;
      userData.step = 'password';
      await sendMessage('üîê *AUTENTICA√á√ÉO REQUERIDA*\n\nPor favor, informe a senha de acesso √† interface web:');
      return;
    }
    
    if (userData.step === 'password') {
      // Verificar credenciais
      const systemUser = await database.buscarUsuarioSistema(userData.login);
      if (systemUser && systemUser.password === text) {
        // Credenciais v√°lidas, pedir n√∫mero do telefone para promover a root
        userData.step = 'telefone_root';
        await sendMessage('‚úÖ Autenticado com sucesso!\n\nAgora informe o n√∫mero do telefone do usu√°rio que deseja promover a root:');
      } else {
        // Credenciais inv√°lidas
        this.awaitingData.delete(userPhone);
        await sendMessage('‚ùå Credenciais inv√°lidas. Comando cancelado.');
      }
      return;
    }
    
    if (userData.step === 'telefone_root') {
      // Promover usu√°rio a root
      await database.alterarRoleUsuario(text, 'root');
      this.awaitingData.delete(userPhone);
      await sendMessage(`‚úÖ Usu√°rio ${text} promovido a root.`);
      return;
    }
    
    if (userData.type === 'parts_request') {
      // Processar solicita√ß√£o de pe√ßas
      userData.step = 'observacoes';
      userData.pecas = text;
      await sendMessage('üìù Observa√ß√µes adicionais (ou digite "n√£o" se n√£o hiver):');
      return;
    }
    
    if (userData.type === 'additional_data') {
      // Adicionar dados a uma OS existente
      const osId = userData.osId;
      await database.adicionarMensagemHistorico(osId, userPhone, text, 'user');
      
      this.awaitingData.delete(userPhone);
      
      await sendMessage(`‚úÖ Informa√ß√µes adicionais adicionadas √† OS #${osId} com sucesso!`);
      
      // Notificar t√©cnico respons√°vel se houver
      const os = await database.buscarOS(osId);
      if (os.tecnico_responsavel) {
        // Aqui voc√™ pode implementar a notifica√ß√£o ao t√©cnico se necess√°rio
      }
      
      return;
    }

    switch (userData.step) {
      case 'nome':
        userData.nome = text;
        userData.step = 'local';
        await sendMessage('2Ô∏è‚É£ Local do atendimento (ex: Recep√ß√£o, Sala 101):');
        break;
        
      case 'local':
        userData.local = text;
        userData.step = 'equipamento';
        await sendMessage('3Ô∏è‚É£ Equipamento com problema (ex: Impressora HP, Computador Dell):');
        break;
        
      case 'equipamento':
        userData.equipamento = text;
        userData.step = 'anydesk';
        await sendMessage('4Ô∏è‚É£ ID do AnyDesk (se aplic√°vel, ou digite "n√£o"):');
        break;
        
      case 'anydesk':
        userData.anydesk = text === 'n√£o' ? null : text;
        userData.step = 'problema';
        await sendMessage('5Ô∏è‚É£ Descreva detalhadamente o problema:');
        break;
        
      case 'problema':
        userData.problema = text;
        
        // Criar OS com todos os dados
        const osData = {
          usuario_nome: userData.nome,
          usuario_telefone: userPhone,
          local_atendimento: userData.local,
          equipamento: userData.equipamento,
          anydesk: userData.anydesk,
          problema: userData.problema,
          setor: 'TI'
        };

        const osId = await database.criarOS(osData);
        await database.adicionarMensagemHistorico(osId, userPhone, userData.problema, 'user');
        
        // Atualizar nome do usu√°rio
        await database.criarOuAtualizarUsuario(userPhone, userData.nome);

        this.awaitingData.delete(userPhone);

        const response = `‚úÖ *CHAMADO CRIADO COM SUCESSO*

üé´ *OS #${osId}*
üë§ Usu√°rio: ${userData.nome}
üìç Local: ${userData.local}
üíª Equipamento: ${userData.equipamento}
${userData.anydesk ? `üñ•Ô∏è AnyDesk: ${userData.anydesk}\n` : ''}üìù Problema: ${userData.problema}
üìÖ Criado em: ${new Date().toLocaleString('pt-BR')}

Seu chamado foi registrado e ser√° atendido em breve!`;

        await sendMessage(response);

        // Notificar grupo t√©cnico
        await this.notifyTechnicalGroup(`üÜï *NOVA OS CRIADA*

üé´ OS #${osId}
üë§ Usu√°rio: ${userData.nome}
üìû Telefone: ${userPhone}
üìç Local: ${userData.local}
üíª Equipamento: ${userData.equipamento}
${userData.anydesk ? `üñ•Ô∏è AnyDesk: ${userData.anydesk}\n` : ''}üìù Problema: ${userData.problema}
üìÖ Criado em: ${new Date().toLocaleString('pt-BR')}`);
        
        // Enviar notifica√ß√£o por e-mail para administradores
        if (config.email.adminEmails.length > 0) {
          try {
            // Buscar OS completa do banco
            const osCompleta = await database.buscarOS(osId);
            
            // Enviar notifica√ß√£o por e-mail
            const emailData = emailTemplates.newOrder(osCompleta);
            await sendAdminNotification(emailData.subject, emailData.text, emailData.html);
          } catch (emailError) {
            console.error('Erro ao enviar notifica√ß√£o por e-mail:', emailError);
          }
        }
        break;

      case 'observacoes':
        // Finalizar solicita√ß√£o de pe√ßas
        const observacoes = text === 'n√£o' ? null : text;
        const user = await database.buscarUsuario(userPhone);
        
        const solicitacaoData = {
          ordem_id: userData.osId,
          tecnico_telefone: userPhone,
          tecnico_nome: user?.nome || 'T√©cnico',
          pecas_solicitadas: userData.pecas,
          observacoes: observacoes
        };

        const solicitacaoId = await database.criarSolicitacaoPecas(solicitacaoData);
        
        this.awaitingData.delete(userPhone);

        const responsePecas = `‚úÖ *SOLICITA√á√ÉO DE PE√áAS CRIADA*

üì¶ Solicita√ß√£o #${solicitacaoId}
üìã OS #${userData.osId}
üë®‚Äçüîß T√©cnico: ${user?.nome || 'T√©cnico'}
üì¶ Pe√ßas solicitadas:
${userData.pecas}
${observacoes ? `üìù Observa√ß√µes: ${observacoes}\n` : ''}
üìÖ Solicitado em: ${new Date().toLocaleString('pt-BR')}

A solicita√ß√£o foi enviada para o almoxarifado.`;

        await sendMessage(responsePecas);

        // Notificar grupo t√©cnico
        await this.notifyTechnicalGroup(`üì¶ *NOVA SOLICITA√á√ÉO DE PE√áAS*

üì¶ Solicita√ß√£o #${solicitacaoId}
üìã OS #${userData.osId}
üë®‚Äçüîß T√©cnico: ${user?.nome || 'T√©cnico'}
üì¶ Pe√ßas: ${userData.pecas}
${observacoes ? `üìù Obs: ${observacoes}` : ''}`);
        break;
    }
  }

  // M√©todos auxiliares
  async notifyTechnicalGroup(message) {
    const bot = require('../bot');
    await bot.notifyTechnicalGroup(message);
  }

  async sendDirectMessage(jid, message) {
    const bot = require('../bot');
    await bot.sendMessage(jid, message);
  }

  // M√©todos auxiliares para outros comandos...
  async handlePing(sendMessage, userRole) {
    if (!['admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para administradores.');
    }

    const startTime = Date.now();
    const stats = await database.obterEstatisticas();
    const endTime = Date.now();

    const response = `
üèì *PING - STATUS DO SISTEMA*

‚è±Ô∏è Tempo de resposta: ${endTime - startTime}ms
üìä Estat√≠sticas:
${Object.entries(stats.porStatus || {}).map(([status, total]) => `‚Ä¢ ${status}: ${total}`).join('\n')}

‚úÖ Sistema operacional
    `;

    await sendMessage(response);
  }

  async handlePrioridade(args, sendMessage, userRole) {
    if (!['tecnico', 'admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para t√©cnicos.');
    }

    if (args.length === 0) {
      return await sendMessage('‚ùå Use: !prioridade [id da OS]');
    }

    const osId = args[0];
    const os = await database.buscarOS(osId);

    if (!os) {
      return await sendMessage(`‚ùå OS #${osId} n√£o encontrada.`);
    }

    await database.definirPrioridadeOS(osId, 1);
    await sendMessage(`‚ö° OS #${osId} marcada como ALTA PRIORIDADE!`);
  }

  async handleSetor(text, sendMessage, userRole) {
    if (!['tecnico', 'admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para t√©cnicos.');
    }

    const match = text.match(/!setor (\d+)=(.+)/);
    if (!match) {
      return await sendMessage('‚ùå Use: !setor [id]=[setor]');
    }

    const osId = match[1];
    const setor = match[2].trim();

    const os = await database.buscarOS(osId);
    if (!os) {
      return await sendMessage(`‚ùå OS #${osId} n√£o encontrada.`);
    }

    await database.alterarSetorOS(osId, setor);
    await sendMessage(`‚úÖ Setor da OS #${osId} alterado para: ${setor}`);
  }

  async handleMensagem(text, sendMessage, userRole) {
    if (!['tecnico', 'admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para t√©cnicos.');
    }

    const match = text.match(/!mensagem (\d+)=(.+)/);
    if (!match) {
      return await sendMessage('‚ùå Use: !mensagem [id]=[texto]');
    }

    const osId = match[1];
    const mensagem = match[2].trim();

    const os = await database.buscarOS(osId);
    if (!os) {
      return await sendMessage(`‚ùå OS #${osId} n√£o encontrada.`);
    }

    // Adicionar mensagem ao hist√≥rico
    await database.adicionarMensagemHistorico(osId, '', mensagem, 'tecnico');

    // Enviar mensagem para o usu√°rio
    const userJid = `${os.usuario_telefone}@s.whatsapp.net`;
    await this.sendDirectMessage(userJid, `
üì® *MENSAGEM DO T√âCNICO - OS #${osId}*

${mensagem}

Para responder, use !status ${osId}
    `);

    await sendMessage(`‚úÖ Mensagem enviada para o usu√°rio da OS #${osId}`);
  }

  async handleChamarAdmin(sendMessage, userRole) {
    if (!['tecnico', 'admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para t√©cnicos.');
    }

    // Notificar administradores
    const admins = await database.listarUsuariosPorRole('admin');
    const roots = await database.listarUsuariosPorRole('root');
    
    const allAdmins = [...admins, ...roots];
    
    for (const admin of allAdmins) {
      const adminJid = `${admin.telefone}@s.whatsapp.net`;
      await this.sendDirectMessage(adminJid, `
üö® *CHAMADA DE ADMINISTRADOR*

Um t√©cnico est√° solicitando ajuda administrativa.
Telefone: ${userRole}
Hor√°rio: ${new Date().toLocaleString('pt-BR')}
      `);
    }

    await sendMessage('‚úÖ Administradores notificados!');
  }

  async handleConfig(sendMessage, userRole) {
    if (!['admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para administradores.');
    }

    const config = `
‚öôÔ∏è *MENU DE CONFIGURA√á√ïES*

‚Ä¢ !listtc - Listar t√©cnicos
‚Ä¢ !listadm - Listar administradores  
‚Ä¢ !menss=[texto] - Alterar sauda√ß√£o
‚Ä¢ !msfinal=[texto] - Alterar mensagem final
‚Ä¢ !tecnico=[num] - Promover a t√©cnico
‚Ä¢ !admin=[num] - Promover a administrador
‚Ä¢ !almoxarifado=[num] - Promover a almoxarifado
‚Ä¢ !ping - Status do sistema
‚Ä¢ !historico - Ver hist√≥rico
    `;

    await sendMessage(config);
  }

  async handleListTecnicos(sendMessage, userRole) {
    if (!['admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para administradores.');
    }

    const tecnicos = await database.listarUsuariosPorRole('tecnico');
    
    if (tecnicos.length === 0) {
      return await sendMessage('üìã Nenhum t√©cnico cadastrado.');
    }

    let response = 'üë®‚Äçüîß *T√âCNICOS CADASTRADOS*\n\n';
    tecnicos.forEach(tecnico => {
      response += `üìû ${tecnico.telefone}\n`;
      response += `üë§ ${tecnico.nome || 'Nome n√£o informado'}\n`;
      response += `üìÖ Desde: ${new Date(tecnico.created_at).toLocaleDateString('pt-BR')}\n\n`;
    });

    await sendMessage(response);
  }

  async handleListAdmins(sendMessage, userRole) {
    if (!['admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para administradores.');
    }

    const admins = await database.listarUsuariosPorRole('admin');
    const roots = await database.listarUsuariosPorRole('root');
    
    let response = 'üëë *ADMINISTRADORES*\n\n';
    
    if (roots.length > 0) {
      response += '*ROOT:*\n';
      roots.forEach(root => {
        response += `üìû ${root.telefone} - ${root.nome || 'Root User'}\n`;
      });
      response += '\n';
    }
    
    if (admins.length > 0) {
      response += '*ADMINS:*\n';
      admins.forEach(admin => {
        response += `üìû ${admin.telefone} - ${admin.nome || 'Admin'}\n`;
      });
    }

    if (roots.length === 0 && admins.length === 0) {
      response = 'üìã Nenhum administrador cadastrado.';
    }

    await sendMessage(response);
  }


  async handleHistorico(sendMessage, userRole) {
    if (!['admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para administradores.');
    }

    const stats = await database.obterEstatisticas();
    
    const response = `
üìä *HIST√ìRICO E ESTAT√çSTICAS*

*OS por Status:*
${Object.entries(stats.porStatus || {}).map(([status, total]) => `‚Ä¢ ${status}: ${total}`).join('\n')}

*OS por T√©cnico:*
${Object.entries(stats.porTecnico || {}).map(([tecnico, total]) => `‚Ä¢ ${tecnico}: ${total}`).join('\n')}

*Pe√ßas por Status:*
${Object.entries(stats.pecasPorStatus || {}).map(([status, total]) => `‚Ä¢ ${status}: ${total}`).join('\n')}
    `;

    await sendMessage(response);
  }

  async handleAlterarSaudacao(text, sendMessage, userRole) {
    if (!['admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para administradores.');
    }

    const match = text.match(/!menss=(.+)/);
    if (!match) {
      return await sendMessage('‚ùå Use: !menss=[nova mensagem de sauda√ß√£o]');
    }

    const novaSaudacao = match[1].trim();
    await database.salvarConfiguracao('mensagem_saudacao', novaSaudacao);
    
    await sendMessage(`‚úÖ Mensagem de sauda√ß√£o alterada para:\n${novaSaudacao}`);
  }

  async handleAlterarMensagemFinal(text, sendMessage, userRole) {
    if (!['admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para administradores.');
    }

    const match = text.match(/!msfinal=(.+)/);
    if (!match) {
      return await sendMessage('‚ùå Use: !msfinal=[nova mensagem final]');
    }

    const novaMensagemFinal = match[1].trim();
    await database.salvarConfiguracao('mensagem_final', novaMensagemFinal);
    
    await sendMessage(`‚úÖ Mensagem final alterada para:\n${novaMensagemFinal}`);
  }

  // Comandos de Pe√ßas
  async handleListPecas(args, sendMessage, userPhone, userRole) {
    if (!['tecnico', 'admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para t√©cnicos.');
    }

    if (args.length === 0) {
      return await sendMessage('‚ùå Use: !listpe√ßas [id da OS]');
    }

    const osId = args[0];
    const os = await database.buscarOS(osId);

    if (!os) {
      return await sendMessage(`‚ùå OS #${osId} n√£o encontrada.`);
    }

    // Iniciar processo de coleta de pe√ßas
    this.awaitingData.set(userPhone, { 
      step: 'pecas', 
      osId: osId,
      type: 'parts_request'
    });

    await sendMessage(`
üì¶ *SOLICITA√á√ÉO DE PE√áAS - OS #${osId}*

Liste as pe√ßas necess√°rias (uma por linha):
Exemplo:
- Mouse √≥ptico USB
- Cabo de rede CAT5e 2m
- Toner HP CF217A

Digite as pe√ßas necess√°rias:
    `);
  }

  async handleVerPecas(sendMessage, userRole) {
    if (!['almoxarifado', 'admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para almoxarifado.');
    }

    const solicitacoes = await database.listarSolicitacoesPecas('pendente');

    if (solicitacoes.length === 0) {
      return await sendMessage('‚úÖ N√£o h√° solicita√ß√µes de pe√ßas pendentes.');
    }

    let response = 'üì¶ *SOLICITA√á√ïES DE PE√áAS PENDENTES*\n\n';
    
    solicitacoes.forEach(sol => {
      response += `üé´ *Solicita√ß√£o #${sol.id}*\n`;
      response += `üìã OS #${sol.ordem_id} - ${sol.usuario_nome}\n`;
      response += `üë®‚Äçüîß T√©cnico: ${sol.tecnico_nome}\n`;
      response += `üìç Local: ${sol.local_atendimento || 'N/I'}\n`;
      response += `üíª Equipamento: ${sol.equipamento || 'N/I'}\n`;
      response += `üì¶ Pe√ßas:\n${sol.pecas_solicitadas}\n`;
      if (sol.observacoes) {
        response += `üìù Obs: ${sol.observacoes}\n`;
      }
      response += `üìÖ Solicitado em: ${new Date(sol.created_at).toLocaleString('pt-BR')}\n\n`;
    });

    response += 'Para atender uma solicita√ß√£o, use: !atender [id]';

    await sendMessage(response);
  }

  async handleAtenderPecas(args, sendMessage, userPhone, userRole) {
    if (!['almoxarifado', 'admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para almoxarifado.');
    }

    if (args.length === 0) {
      return await sendMessage('‚ùå Use: !atender [id da solicita√ß√£o]');
    }

    const solicitacaoId = args[0];
    const solicitacao = await database.buscarSolicitacaoPecas(solicitacaoId);

    if (!solicitacao) {
      return await sendMessage(`‚ùå Solicita√ß√£o #${solicitacaoId} n√£o encontrada.`);
    }

    const user = await database.buscarUsuario(userPhone);
    await database.atualizarStatusSolicitacaoPecas(solicitacaoId, 'atendida', user?.nome || userPhone);

    await sendMessage(`‚úÖ Solicita√ß√£o #${solicitacaoId} marcada como atendida!`);

    // Notificar t√©cnico respons√°vel
    const tecnicoJid = `${solicitacao.tecnico_telefone}@s.whatsapp.net`;
    await this.sendDirectMessage(tecnicoJid, `
‚úÖ *PE√áAS DISPONIBILIZADAS*

üì¶ Solicita√ß√£o #${solicitacaoId}
üìã OS #${solicitacao.ordem_id}
üë®‚Äçüîß T√©cnico: ${solicitacao.tecnico_nome}
üì¶ Pe√ßas: ${solicitacao.pecas_solicitadas}
üë§ Atendido por: ${user?.nome || userPhone}

As pe√ßas est√£o dispon√≠veis para retirada no almoxarifado.
    `);

    // Notificar grupo t√©cnico
    await this.notifyTechnicalGroup(`
‚úÖ *PE√áAS DISPONIBILIZADAS*

üì¶ Solicita√ß√£o #${solicitacaoId} - OS #${solicitacao.ordem_id}
üë®‚Äçüîß T√©cnico: ${solicitacao.tecnico_nome}
üë§ Atendido por: ${user?.nome || userPhone}
üì¶ Pe√ßas dispon√≠veis para retirada
    `);
  }

  // Implementar outros m√©todos conforme necess√°rio...
  async handleMenu(sendMessage, userRole) {
    if (!['tecnico', 'admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para t√©cnicos.');
    }

    const menu = `
üîß *MENU T√âCNICO*

‚Ä¢ !atendendo [id] - Assumir OS
‚Ä¢ !prioridade [id] - Marcar como priorit√°rio
‚Ä¢ !setor [id]=[setor] - Alterar setor
‚Ä¢ !mensagem [id]=[texto] - Enviar mensagem
‚Ä¢ !list - Listar OS abertas
‚Ä¢ !finalizado [id] - Finalizar OS
‚Ä¢ !listpe√ßas [id] - Solicitar pe√ßas para OS
‚Ä¢ !adm - Chamar administrador
    `;

    await sendMessage(menu);
  }

  async handleFinalizado(args, sendMessage, userRole) {
    if (!['tecnico', 'admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para t√©cnicos.');
    }

    if (args.length === 0) {
      return await sendMessage('‚ùå Use: !finalizado [id da OS]');
    }

    const osId = args[0];
    const os = await database.buscarOS(osId);

    if (!os) {
      return await sendMessage(`‚ùå OS #${osId} n√£o encontrada.`);
    }

    await database.atualizarStatusOS(osId, 'finalizada');
    await database.adicionarMensagemHistorico(osId, '', 'OS finalizada pelo t√©cnico', 'system');

    await sendMessage(`‚úÖ OS #${osId} finalizada com sucesso!`);

    // Notificar grupo t√©cnico
    await this.notifyTechnicalGroup(`
‚úÖ *OS FINALIZADA*

üé´ OS #${osId}
üë§ Cliente: ${os.usuario_nome}
üìù Problema: ${os.problema}
üîß Finalizada pelo t√©cnico
    `);
    
    // Enviar notifica√ß√£o por e-mail para administradores
    if (config.email.adminEmails.length > 0) {
      try {
        // Buscar OS completa do banco (com dados atualizados)
        const osCompleta = await database.buscarOS(osId);
        
        // Enviar notifica√ß√£o por e-mail
        const emailData = emailTemplates.orderCompleted(osCompleta);
        await sendAdminNotification(emailData.subject, emailData.text, emailData.html);
      } catch (emailError) {
        console.error('Erro ao enviar notifica√ß√£o de OS finalizada por e-mail:', emailError);
      }
    }
  }

  async handlePromoverAlmoxarifado(text, sendMessage, userRole) {
    if (!['admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para administradores.');
    }

    const match = text.match(/!almoxarifado=(.+)/);
    if (!match) {
      return await sendMessage('‚ùå Use: !almoxarifado=[n√∫mero do telefone]');
    }

    const telefone = match[1].trim();
    await database.alterarRoleUsuario(telefone, 'almoxarifado');
    
    await sendMessage(`‚úÖ Usu√°rio ${telefone} promovido a almoxarifado.`);
  }

  // Comandos do Sistema
  async handleCriarUsuario(text, sendMessage, userPhone, userRole) {
    if (!['root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para usu√°rios root.');
    }

    const match = text.match(/!user\s+(.+)\s+(.+)/);
    if (!match) {
      return await sendMessage('‚ùå Use: !user [username] [password]');
    }

    const [, username, password] = match;

    try {
      const userData = {
        username: username.trim(),
        password: password.trim(),
        telefone: userPhone,
        role: 'admin',
        created_by: userPhone
      };

      await database.criarUsuarioSistema(userData);
      
      await sendMessage(`‚úÖ Usu√°rio de sistema criado com sucesso!
      
üë§ Username: ${username}
üîë Password: ${password}
üåê Acesso: Interface web de configura√ß√µes

O usu√°rio pode acessar as configura√ß√µes do sistema atrav√©s da interface web.`);

    } catch (error) {
      if (error.message.includes('UNIQUE constraint failed')) {
        await sendMessage('‚ùå Nome de usu√°rio j√° existe. Escolha outro nome.');
      } else {
        await sendMessage('‚ùå Erro ao criar usu√°rio. Tente novamente.');
      }
    }
  }

  async handleGrafico(sendMessage, userRole) {
    if (!['tecnico', 'admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para t√©cnicos e administradores.');
    }

    try {
      const stats = await database.obterEstatisticasGraficos();
      
      let response = 'üìä *ESTAT√çSTICAS DO SISTEMA*\n\n';
      
      // OS por m√™s
      if (stats.osPorMes && stats.osPorMes.length > 0) {
        response += 'üìà *OS por M√™s (√öltimos 12 meses):*\n';
        stats.osPorMes.forEach(item => {
          const [ano, mes] = item.mes.split('-');
          const mesNome = new Date(ano, mes - 1).toLocaleDateString('pt-BR', { month: 'long', year: 'numeric' });
          response += `‚Ä¢ ${mesNome}: ${item.total} (${item.finalizadas} finalizadas)\n`;
        });
        response += '\n';
      }

      // OS por t√©cnico
      if (stats.osPorTecnico && stats.osPorTecnico.length > 0) {
        response += 'üë®‚Äçüîß *OS por T√©cnico (√öltimos 30 dias):*\n';
        stats.osPorTecnico.forEach(item => {
          const eficiencia = item.total > 0 ? Math.round((item.finalizadas / item.total) * 100) : 0;
          response += `‚Ä¢ ${item.tecnico_responsavel}: ${item.total} OS (${eficiencia}% finalizadas)\n`;
        });
        response += '\n';
      }

      // Pe√ßas por status
      if (stats.pecasPorStatus && stats.pecasPorStatus.length > 0) {
        response += 'üì¶ *Solicita√ß√µes de Pe√ßas (√öltimos 30 dias):*\n';
        stats.pecasPorStatus.forEach(item => {
          const statusEmoji = {
            'pendente': 'üü°',
            'em_separacao': 'üîµ',
            'atendida': 'üü¢',
            'cancelada': 'üî¥'
          };
          response += `${statusEmoji[item.status] || '‚ö™'} ${item.status}: ${item.total}\n`;
        });
        response += '\n';
      }

      // Tempo m√©dio de resolu√ß√£o
      if (stats.tempoMedioResolucao > 0) {
        const horas = Math.floor(stats.tempoMedioResolucao);
        const minutos = Math.round((stats.tempoMedioResolucao - horas) * 60);
        response += `‚è±Ô∏è *Tempo M√©dio de Resolu√ß√£o:* ${horas}h ${minutos}min\n\n`;
      }

      response += 'üåê Para gr√°ficos detalhados, acesse a interface web do sistema.';

      await sendMessage(response);

    } catch (error) {
      console.error('Erro ao gerar estat√≠sticas:', error);
      await sendMessage('‚ùå Erro ao gerar estat√≠sticas. Tente novamente.');
    }
  }

  async handleBackup(sendMessage, userRole) {
    if (!['admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para administradores.');
    }

    try {
      const fs = require('fs');
      const path = require('path');
      
      // Criar diret√≥rio de backup se n√£o existir
      const backupDir = './backups';
      if (!fs.existsSync(backupDir)) {
        fs.mkdirSync(backupDir, { recursive: true });
      }

      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const backupName = `backup_${timestamp}.db`;
      const backupPath = path.join(backupDir, backupName);
      
      // Copiar arquivo do banco de dados
      fs.copyFileSync('./db/atendimento.db', backupPath);
      
      // Obter tamanho do arquivo
      const stats = fs.statSync(backupPath);
      const fileSizeInBytes = stats.size;
      const fileSizeInMB = (fileSizeInBytes / (1024 * 1024)).toFixed(2);

      // Registrar backup no banco
      await database.criarRegistroBackup({
        backup_name: backupName,
        backup_path: backupPath,
        backup_size: fileSizeInBytes,
        backup_type: 'manual',
        status: 'completed'
      });

      await sendMessage(`‚úÖ *BACKUP CRIADO COM SUCESSO*

üìÅ Nome: ${backupName}
üìç Local: ${backupPath}
üìä Tamanho: ${fileSizeInMB} MB
üìÖ Data: ${new Date().toLocaleString('pt-BR')}

O backup foi salvo com sucesso e pode ser usado para restaurar o sistema.`);

    } catch (error) {
      console.error('Erro ao criar backup:', error);
      await sendMessage('‚ùå Erro ao criar backup. Verifique as permiss√µes do sistema.');
    }
  }

  async handleSistema(sendMessage, userRole) {
    if (!['admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para administradores.');
    }

    try {
      const os = require('os');
      const fs = require('fs');
      
      // Informa√ß√µes do sistema
      const totalMemory = (os.totalmem() / 1024 / 1024 / 1024).toFixed(2);
      const freeMemory = (os.freemem() / 1024 / 1024 / 1024).toFixed(2);
      const usedMemory = (totalMemory - freeMemory).toFixed(2);
      
      // Informa√ß√µes do processo Node.js
      const processMemory = (process.memoryUsage().rss / 1024 / 1024).toFixed(2);
      const uptime = Math.floor(process.uptime() / 3600);
      
      // Tamanho do banco de dados
      let dbSize = 0;
      try {
        const dbStats = fs.statSync('./db/atendimento.db');
        dbSize = (dbStats.size / 1024 / 1024).toFixed(2);
      } catch (e) {
        dbSize = 'N/A';
      }

      // Status da IA
      const iaStatus = ollamaClient.getStatus();

      // Estat√≠sticas do banco
      const stats = await database.obterEstatisticas();
      const totalOS = Object.values(stats.porStatus || {}).reduce((a, b) => a + b, 0);
      const totalPecas = Object.values(stats.pecasPorStatus || {}).reduce((a, b) => a + b, 0);

      const response = `üñ•Ô∏è *INFORMA√á√ïES DO SISTEMA*

üíæ *Mem√≥ria:*
‚Ä¢ Total: ${totalMemory} GB
‚Ä¢ Usada: ${usedMemory} GB
‚Ä¢ Livre: ${freeMemory} GB
‚Ä¢ Bot: ${processMemory} MB

‚è±Ô∏è *Tempo Ativo:* ${uptime} horas

ü§ñ *IA (Ollama):*
‚Ä¢ Status: ${iaStatus.available ? '‚úÖ Conectada' : '‚ùå Desconectada'}
‚Ä¢ URL: ${iaStatus.baseUrl}
‚Ä¢ Modelo: ${iaStatus.model}

üóÑÔ∏è *Banco de Dados:*
‚Ä¢ Tamanho: ${dbSize} MB
‚Ä¢ Total OS: ${totalOS}
‚Ä¢ Total Pe√ßas: ${totalPecas}

üìä *OS por Status:*
${Object.entries(stats.porStatus || {}).map(([status, total]) => `‚Ä¢ ${status}: ${total}`).join('\n')}

üåê Para configura√ß√µes avan√ßadas, acesse a interface web do sistema.`;

      await sendMessage(response);

    } catch (error) {
      console.error('Erro ao obter informa√ß√µes do sistema:', error);
      await sendMessage('‚ùå Erro ao obter informa√ß√µes do sistema.');
    }
  }

  // Comandos de controle da IA
  async handleIAOn(sendMessage, userRole) {
    if (!['admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para administradores.');
    }

    try {
      // Salvar configura√ß√£o no banco
      await database.salvarConfiguracao('ollama_enabled', 'true');
      
      // Reativar conex√£o
      await ollamaClient.checkConnection();
      
      const status = ollamaClient.getStatus();
      
      if (status.available) {
        await sendMessage(`‚úÖ *IA ATIVADA COM SUCESSO*

ü§ñ Status: Conectada
üîó URL: ${status.baseUrl}
üì¶ Modelo: ${status.model}

A IA agora analisar√° automaticamente as mensagens dos usu√°rios.`);
      } else {
        await sendMessage(`‚ö†Ô∏è *IA ATIVADA MAS N√ÉO CONECTADA*

‚ùå Ollama n√£o est√° dispon√≠vel
üîó URL: ${status.baseUrl}
üì¶ Modelo: ${status.model}

Verifique se o Ollama est√° rodando: \`ollama serve\``);
      }

    } catch (error) {
      console.error('Erro ao ativar IA:', error);
      await sendMessage('‚ùå Erro ao ativar IA. Verifique se o Ollama est√° instalado e rodando.');
    }
  }

  async handleIAOff(sendMessage, userRole) {
    if (!['admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para administradores.');
    }

    try {
      // Salvar configura√ß√£o no banco
      await database.salvarConfiguracao('ollama_enabled', 'false');
      
      await sendMessage(`‚ùå *IA DESATIVADA*

ü§ñ Status: Desconectada
üìù Modo: Fallback ativo

O bot continuar√° funcionando normalmente, mas sem an√°lise inteligente de mensagens.
Para reativar, use: !iaon`);

    } catch (error) {
      console.error('Erro ao desativar IA:', error);
      await sendMessage('‚ùå Erro ao desativar IA.');
    }
  }

  async handleIAStatus(sendMessage, userRole) {
    if (!['tecnico', 'admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para t√©cnicos e administradores.');
    }

    try {
      const status = ollamaClient.getStatus();
      const isEnabled = await database.buscarConfiguracao('ollama_enabled') !== 'false';
      
      let response = `ü§ñ *STATUS DA IA (OLLAMA)*\n\n`;
      
      response += `‚öôÔ∏è *Configura√ß√£o:*\n`;
      response += `‚Ä¢ Habilitada: ${isEnabled ? '‚úÖ Sim' : '‚ùå N√£o'}\n`;
      response += `‚Ä¢ URL: ${status.baseUrl}\n`;
      response += `‚Ä¢ Modelo: ${status.model}\n\n`;
      
      response += `üîó *Conex√£o:*\n`;
      response += `‚Ä¢ Status: ${status.available ? '‚úÖ Conectada' : '‚ùå Desconectada'}\n\n`;
      
      if (status.available) {
        response += `‚úÖ *IA Funcionando Normalmente*\n`;
        response += `‚Ä¢ An√°lise autom√°tica de mensagens ativa\n`;
        response += `‚Ä¢ Classifica√ß√£o inteligente funcionando\n`;
        response += `‚Ä¢ Primeira intera√ß√£o personalizada ativa\n\n`;
      } else {
        response += `‚ö†Ô∏è *IA em Modo Fallback*\n`;
        response += `‚Ä¢ Bot funciona sem an√°lise inteligente\n`;
        response += `‚Ä¢ Primeira mensagem cria OS automaticamente\n`;
        response += `‚Ä¢ Para ativar: verifique se Ollama est√° rodando\n\n`;
      }
      
      response += `üîß *Comandos de Controle:*\n`;
      response += `‚Ä¢ !iaon - Ativar IA\n`;
      response += `‚Ä¢ !iaoff - Desativar IA\n`;
      response += `‚Ä¢ !iastatus - Ver este status`;

      await sendMessage(response);

    } catch (error) {
      console.error('Erro ao obter status da IA:', error);
      await sendMessage('‚ùå Erro ao obter status da IA.');
    }
  }

  // Comando para mencionar usu√°rio root
  async handleMencionarRoot(sendMessage, userRole) {
    try {
      const rootUser = await database.buscarUsuarioRootPrincipal();
      
      if (!rootUser) {
        return await sendMessage('‚ùå Nenhum usu√°rio root encontrado no sistema.');
      }

      const response = `üëë *ROOT DO SISTEMA*

üìû @${rootUser.telefone}
üë§ ${rootUser.nome || 'Root User'}
üìÖ Cadastrado em: ${new Date(rootUser.created_at).toLocaleDateString('pt-BR')}

Para contato direto com o administrador principal do sistema.`;

      await sendMessage(response);
    } catch (error) {
      console.error('Erro ao buscar usu√°rio root:', error);
      await sendMessage('‚ùå Erro ao buscar informa√ß√µes do usu√°rio root.');
    }
  }

  // Comando para definir grupo t√©cnico
  async handleDefinirGrupoTecnico(sendMessage, userPhone, userRole, isGrupoTecnico) {
    if (!['admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para administradores.');
    }

    if (!isGrupoTecnico) {
      return await sendMessage('‚ùå Este comando s√≥ pode ser usado em grupos.');
    }

    try {
      // Obter o ID do grupo atual (ser√° passado pelo bot.js)
      const bot = require('../bot');
      const groupId = await this.getCurrentGroupId(userPhone);
      
      if (!groupId) {
        return await sendMessage('‚ùå N√£o foi poss√≠vel identificar o grupo atual.');
      }

      // Definir este grupo como grupo t√©cnico
      await database.definirGrupoTecnico(groupId, userPhone);

      const response = `‚úÖ *GRUPO T√âCNICO DEFINIDO*

üè¢ Este grupo foi configurado como o grupo t√©cnico oficial.

üìã *Funcionalidades ativadas:*
‚Ä¢ Recebimento de notifica√ß√µes de novas OS
‚Ä¢ Comandos t√©cnicos e administrativos
‚Ä¢ Solicita√ß√µes de pe√ßas
‚Ä¢ Atualiza√ß√µes de status

üë• *Comandos dispon√≠veis:*
‚Ä¢ !adm @usuario - Promover a administrador
‚Ä¢ !tecnico @usuario - Promover a t√©cnico  
‚Ä¢ !almoxarifado @usuario - Promover a almoxarifado
‚Ä¢ !root - Mencionar root do sistema

üìÖ Configurado em: ${new Date().toLocaleString('pt-BR')}
üë§ Por: ${userPhone}`;

      await sendMessage(response);

      // Notificar usu√°rios root sobre a mudan√ßa
      const rootUsers = await database.listarUsuariosPorRole('root');
      for (const root of rootUsers) {
        if (root.telefone !== userPhone) {
          const rootJid = `${root.telefone}@s.whatsapp.net`;
          await this.sendDirectMessage(rootJid, `
üîÑ *GRUPO T√âCNICO ALTERADO*

O grupo t√©cnico foi redefinido por ${userPhone}.
Novo grupo: ${groupId}
Data: ${new Date().toLocaleString('pt-BR')}
          `);
        }
      }

    } catch (error) {
      console.error('Erro ao definir grupo t√©cnico:', error);
      await sendMessage('‚ùå Erro ao definir grupo t√©cnico. Tente novamente.');
    }
  }

  // M√©todo auxiliar para obter ID do grupo atual
  async getCurrentGroupId(userPhone) {
    // Este m√©todo ser√° implementado para obter o ID do grupo atual
    // Por enquanto, retornamos null - ser√° implementado no bot.js
    return null;
  }

  // Atualizar m√©todos de promo√ß√£o para suportar men√ß√µes
  async handlePromoverTecnico(text, sendMessage, userRole) {
    if (!['admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para administradores.');
    }

    // Verificar se h√° men√ß√µes na mensagem
    const telefonesMencionados = database.extrairTelefonesDeMencoes(text);
    
    if (telefonesMencionados.length > 0) {
      // Usar o primeiro telefone mencionado
      const telefone = telefonesMencionados[0];
      await database.alterarRoleUsuario(telefone, 'tecnico');
      
      await sendMessage(`‚úÖ Usu√°rio @${telefone} promovido a t√©cnico.`);
      return;
    }

    // Fallback para o formato antigo
    const match = text.match(/!tecnico=(.+)/);
    if (!match) {
      return await sendMessage('‚ùå Use: !tecnico @usuario ou !tecnico=[n√∫mero do telefone]');
    }

    const telefone = match[1].trim();
    await database.alterarRoleUsuario(telefone, 'tecnico');
    
    await sendMessage(`‚úÖ Usu√°rio ${telefone} promovido a t√©cnico.`);
  }

  async handlePromoverAdmin(text, sendMessage, userRole) {
    if (!['root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para usu√°rios root.');
    }

    // Verificar se h√° men√ß√µes na mensagem
    const telefonesMencionados = database.extrairTelefonesDeMencoes(text);
    
    if (telefonesMencionados.length > 0) {
      // Usar o primeiro telefone mencionado
      const telefone = telefonesMencionados[0];
      await database.alterarRoleUsuario(telefone, 'admin');
      
      await sendMessage(`‚úÖ Usu√°rio @${telefone} promovido a administrador.`);
      return;
    }

    // Fallback para o formato antigo
    const match = text.match(/!admin=(.+)/);
    if (!match) {
      return await sendMessage('‚ùå Use: !admin @usuario ou !admin=[n√∫mero do telefone]');
    }

    const telefone = match[1].trim();
    await database.alterarRoleUsuario(telefone, 'admin');
    
    await sendMessage(`‚úÖ Usu√°rio ${telefone} promovido a administrador.`);
  }

  async handlePromoverAlmoxarifado(text, sendMessage, userRole) {
    if (!['admin', 'root'].includes(userRole)) {
      return await sendMessage('‚ùå Comando dispon√≠vel apenas para administradores.');
    }

    // Verificar se h√° men√ß√µes na mensagem
    const telefonesMencionados = database.extrairTelefonesDeMencoes(text);
    
    if (telefonesMencionados.length > 0) {
      // Usar o primeiro telefone mencionado
      const telefone = telefonesMencionados[0];
      await database.alterarRoleUsuario(telefone, 'almoxarifado');
      
      await sendMessage(`‚úÖ Usu√°rio @${telefone} promovido a almoxarifado.`);
      return;
    }

    // Fallback para o formato antigo
    const match = text.match(/!almoxarifado=(.+)/);
    if (!match) {
      return await sendMessage('‚ùå Use: !almoxarifado @usuario ou !almoxarifado=[n√∫mero do telefone]');
    }

    const telefone = match[1].trim();
    await database.alterarRoleUsuario(telefone, 'almoxarifado');
    
    await sendMessage(`‚úÖ Usu√°rio ${telefone} promovido a almoxarifado.`);
  }
}

module.exports = new CommandHandler();
